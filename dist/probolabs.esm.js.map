{"version":3,"file":"probolabs.esm.js","sources":["../src/constants.js","../src/utils.js","../src/finders.js","../src/highlight.js"],"sourcesContent":["export const ElementTag = {\n  CLICKABLE: \"CLICKABLE\", // button, link, toggle switch, checkbox, radio, dropdowns, clickable divs\n  FILLABLE: \"FILLABLE\", // input, textarea content_editable, date picker??\n  SELECTABLE: \"SELECTABLE\", // select\n  NON_INTERACTIVE_ELEMENT: 'NON_INTERACTIVE_ELEMENT',\n};\n\nexport class ElementInfo {\n  constructor(element, index, {tag, type, text, html, xpath, css_selector, bounding_box}) {\n    this.index = index.toString();\n    this.tag = tag;\n    this.type = type;\n    this.text = text;\n    this.html = html;\n    this.xpath = xpath;\n    this.css_selector = css_selector;\n    this.bounding_box = bounding_box;\n    this.element = element;\n    this.depth = -1;\n  }\n\n  getSelector() {\n    return this.xpath ? this.xpath : this.css_selector;\n  }\n\n  getDepth() {\n    if (this.depth >= 0) {\n      return this.depth;\n    }\n\n    // Handle shadow DOM by counting host elements as 1 level\n    let depth = 0;\n    let currentElement = this.element;\n    \n    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\n      depth++;\n      \n      currentElement = currentElement.parentElement;      \n      if (currentElement && currentElement.nodeType !== Node.ELEMENT_NODE && currentElement.getRootNode() instanceof ShadowRoot) {\n        // Skip to shadow host, counting it as one level\n        currentElement = currentElement.getRootNode().host;\n      }\n    }\n    \n    this.depth = depth;\n    return this.depth;\n  }\n}\n","import { ElementInfo } from './constants';\n\n\n\nexport const getElementByXPathOrCssSelector = (element_info) => {\n  let element;\n\n  if (element_info.xpath) { //try xpath if exists\n    element = document.evaluate(\n      element_info.xpath, \n      document, \n      null, \n      XPathResult.FIRST_ORDERED_NODE_TYPE, \n      null\n    ).singleNodeValue;\n  \n    if (!element) {\n      console.warn('Failed to find element with xpath:', element_info.xpath);\n    }\n  }\n  else { //try CSS selector\n    element = document.querySelector(element_info.css_selector);\n    // console.log('found element by CSS elector: ', element);\n    if (!element) {\n      console.warn('Failed to find element with CSS selector:', element_info.css_selector);\n    }\n  }\n\n  return element;\n};\n\nexport function generateXPath(element) {\n  if (!element || element.getRootNode() instanceof ShadowRoot) return '';\n  \n  // If element has an id, use that (it's unique and shorter)\n  if (element.id) {\n    return `//*[@id=\"${element.id}\"]`;\n  }\n  \n  const parts = [];\n  let current = element;\n  \n  while (current && current.nodeType === Node.ELEMENT_NODE) {\n    let index = 1;\n    let sibling = current.previousSibling;\n    \n    while (sibling) {\n      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === current.tagName) {\n        index++;\n      }\n      sibling = sibling.previousSibling;\n    }\n    \n    const tagName = current.tagName.toLowerCase();\n    parts.unshift(`${tagName}[${index}]`);\n    current = current.parentNode;\n  }\n  \n  return '/' + parts.join('/');\n}\n\nexport function generateCssPath(element) {\n  const path = [];\n  while (element.nodeType === Node.ELEMENT_NODE) {    \n    let selector = element.nodeName.toLowerCase();\n    \n    // if (element.id) {\n    //   //escape special characters\n    //   const normalized_id = element.id.replace(/[:;.#()[\\]!@$%^&*]/g, '\\\\$&');\n    //   selector = `#${normalized_id}`;\n    //   path.unshift(selector);\n    //   break;\n    // } \n    \n    let sibling = element;\n    let nth = 1;\n    while (sibling = sibling.previousElementSibling) {\n      if (sibling.nodeName.toLowerCase() === selector) nth++;\n    }\n    sibling = element;\n    let singleChild = true;\n    while (sibling = sibling.nextElementSibling) {\n      if (sibling.nodeName.toLowerCase() === selector) {\n        singleChild = false;\n        break;\n      }\n    }\n    if (nth > 1 || !singleChild) selector += `:nth-of-type(${nth})`;\n  \n    path.unshift(selector);\n\n    if (element.assignedSlot) {\n      element = element.assignedSlot;\n    }\n    else {\n      element = element.parentNode;\n      // Check if we're at a shadow root\n      if (element.nodeType !== Node.ELEMENT_NODE && element.getRootNode() instanceof ShadowRoot) {\n        // Get the shadow root's host element\n        element = element.getRootNode().host;     \n      }\n    }\n  }\n  return path.join(' > ');\n}\n\nexport function cleanHTML(rawHTML) {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(rawHTML, \"text/html\");\n\n  function cleanElement(element) {\n    const allowedAttributes = new Set([\n      \"role\",\n      \"type\",\n      \"class\",\n      \"href\",\n      \"alt\",\n      \"title\",\n      \"readonly\",\n      \"checked\",\n      \"enabled\",\n      \"disabled\",\n    ]);\n\n    [...element.attributes].forEach(attr => {\n      const name = attr.name.toLowerCase();\n      const value = attr.value;\n\n      const isTestAttribute = /^(testid|test-id|data-test-id)$/.test(name);\n      const isDataAttribute = name.startsWith(\"data-\") && value;\n      const isBooleanAttribute = [\"readonly\", \"checked\", \"enabled\", \"disabled\"].includes(name);\n\n      if (!allowedAttributes.has(name) && !isDataAttribute && !isTestAttribute && !isBooleanAttribute) {\n        element.removeAttribute(name);\n      }\n    });\n\n    // Handle SVG content - more aggressive replacement\n    if (element.tagName.toLowerCase() === \"svg\") {\n      // Remove all attributes except class and role\n      [...element.attributes].forEach(attr => {\n        const name = attr.name.toLowerCase();\n        if (name !== \"class\" && name !== \"role\") {\n          element.removeAttribute(name);\n        }\n      });\n      element.innerHTML = \"CONTENT REMOVED\";\n    } else {\n      // Recursively clean child elements\n      Array.from(element.children).forEach(cleanElement);\n    }\n\n    // Only remove empty elements that aren't semantic or icon elements\n    const keepEmptyElements = ['i', 'span', 'svg', 'button', 'input'];\n    if (!keepEmptyElements.includes(element.tagName.toLowerCase()) && \n        !element.children.length && \n        !element.textContent.trim()) {\n      element.remove();\n    }\n  }\n\n  // Process all elements in the document body\n  Array.from(doc.body.children).forEach(cleanElement);\n  return doc.body.innerHTML;\n}\n\nexport function getElementInfo(element, index) {\n  // Get text content with spaces between elements\n  function getTextContent(element) {\n    const walker = document.createTreeWalker(\n      element,\n      NodeFilter.SHOW_TEXT,\n      null,\n      false\n    );\n\n    let text = '';\n    let node;\n\n    while (node = walker.nextNode()) {\n      const trimmedText = node.textContent.trim();\n      if (trimmedText) {\n        // Add space if there's already text\n        if (text) {\n          text += ' ';\n        }\n        text += trimmedText;\n      }\n    }\n\n    return text;\n  }\n\n  const xpath = generateXPath(element);\n  const css_selector = generateCssPath(element);\n\n  // Return element info with pre-calculated values\n  return new ElementInfo(element, index, {\n    tag: element.tagName.toLowerCase(),\n    type: element.type || '',\n    text: getTextContent(element),\n    html: cleanHTML(element.outerHTML),\n    xpath: xpath,\n    css_selector: css_selector,\n    bounding_box: element.getBoundingClientRect()\n  });\n}\n\n\n\n\nconst filterZeroDimensions = (elementInfo) => {\n  const rect = elementInfo.bounding_box;\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const style = window.getComputedStyle(elementInfo.element);\n  const isVisible = style.display !== 'none' && style.visibility !== 'hidden';\n  \n  if (!hasSize || !isVisible) {\n    // if (elementInfo.element.isConnected) {\n    //   console.log('Filtered out invisible/zero-size element:', {\n    //     tag: elementInfo.tag,\n    //     xpath: elementInfo.xpath,\n    //     element: elementInfo.element,\n    //     hasSize,\n    //     isVisible,\n    //     dimensions: rect\n    //   });\n    // }\n    return false;\n  }\n  return true;\n};\n\nexport function uniquifyElements(elements) {\n  const seen = new Set();\n  console.log(`Starting uniquification with ${elements.length} elements`);\n  // First filter out elements with zero dimensions\n  const nonZeroElements = elements.filter(filterZeroDimensions);\n  // sort by CSS selector depth so parents are processed first\n  nonZeroElements.sort((a, b) => a.getDepth() - b.getDepth());\n  console.log(`After dimension filtering: ${nonZeroElements.length} elements remain (${elements.length - nonZeroElements.length} removed)`);\n  \n  nonZeroElements.forEach(element_info => seen.add(element_info.css_selector));\n    \n  nonZeroElements.forEach(info => {\n    // if (!info.xpath) {\n    //   console.log(`Element ${info.index}:`, info);\n    // }\n  });\n  const filteredByParent = nonZeroElements.filter(element_info => {\n    const parent = findClosestParent(seen, element_info);\n    const keep = parent == null || shouldKeepNestedElement(element_info, parent);\n    // if (!keep && !element_info.xpath) {\n    //   console.log(\"Filtered out element \", element_info,\" because it's a nested element of \", parent);\n    // }\n    return keep;\n  });\n\n  console.log(`After parent/child filtering: ${filteredByParent.length} elements remain (${nonZeroElements.length - filteredByParent.length} removed)`);\n\n  // Final overlap filtering\n  const filteredResults = filteredByParent.filter(element => {\n    // Look for any element that came BEFORE this one in the array\n    const hasEarlierOverlap = filteredByParent.some(other => {\n      // Only check elements that came before (lower index)\n      if (filteredByParent.indexOf(other) >= filteredByParent.indexOf(element)) {\n        return false;\n      }\n      \n      return areElementsOverlapping(element, other);\n    });\n\n    // Keep element if it has no earlier overlapping elements\n    return !hasEarlierOverlap;\n  });\n  \n  // further cleanup of of the element html to remove any element that we have already seen\n  \n\n  console.log(`Final elements after filtering: ${filteredResults.length} (${filteredByParent.length - filteredResults.length} removed by overlap)`);\n  \n  // for debugging purposes, add a data-probolabs_index attribute to the element\n  // filteredResults.forEach((elementInfo, index) => {\n  //   // elementInfo.index = index.toString();\n  //   const foundElement = elementInfo.element; //getElementByXPathOrCssSelector(element);\n  //   if (foundElement) {\n  //     foundElement.dataset.probolabs_index = index.toString();\n  //   }\n  // });\n\n  // final path cleanup the html\n  // filteredResults.forEach(elementInfo => {\n  //   const foundElement = elementInfo.element; //getElementByXPathOrCssSelector(element);\n  //   if (foundElement) {\n  //     //  const parser = new DOMParser();\n  //     //  const doc = parser.parseFromString(foundElement.outerHTML, \"text/html\");\n  //     //  doc.querySelectorAll('[data-probolabs_index]').forEach(el => {\n  //     //    if (el.dataset.probolabs_index !== element.index) {\n  //     //      el.remove();\n  //     //    }\n  //     //  });\n  //     //  // Get the first element from the processed document\n  //     //  const container = doc.body.firstElementChild;\n  //     const clone = foundElement.cloneNode(false);  // false = don't clone children\n  //     elementInfo.element.html = clone.outerHTML;\n  //   }\n  // });\n\n  return filteredResults;\n\n\n}\n\n\n\nconst areElementsOverlapping = (element1, element2) => {\n  if (element1.css_selector === element2.css_selector) {\n    return true;\n  }\n  \n  const box1 = element1.bounding_box;\n  const box2 = element2.bounding_box;\n  \n  return box1.x === box2.x &&\n         box1.y === box2.y &&\n         box1.width === box2.width &&\n         box1.height === box2.height;\n        //  element1.text === element2.text &&\n        //  element2.tag === 'a';\n};\n\nfunction findClosestParent(seen, element_info) {  \n  // //Use element child/parent queries\n  // let parent = element_info.element.parentNode;\n  // if (parent.getRootNode() instanceof ShadowRoot) {\n  //   // Get the shadow root's host element\n  //   parent = parent.getRootNode().host;    \n  // }\n\n  // while (parent.nodeType === Node.ELEMENT_NODE) {    \n  //   const css_selector = generateCssPath(parent);\n  //   if (seen.has(css_selector)) {\n  //       console.log(\"element \", element_info, \" closest parent is \", parent)\n  //       return parent;      \n  //   }\n  //   parent = parent.parentNode;\n  //   if (parent.getRootNode() instanceof ShadowRoot) {\n  //     // Get the shadow root's host element\n  //     parent = parent.getRootNode().host;      \n  //   }\n  // }\n\n  // Split the xpath into segments\n  const segments = element_info.css_selector.split(' > ');\n  \n  // Try increasingly shorter paths until we find one in the seen set\n  for (let i = segments.length - 1; i > 0; i--) {\n    const parentPath = segments.slice(0, i).join(' > ');\n    if (seen.has(parentPath)) {\n      return parentPath;\n    }\n  }\n\n  return null;\n}\n\nfunction shouldKeepNestedElement(elementInfo, parent) {\n  let result = false;\n  \n  // If this is a checkbox/radio input\n  if (elementInfo.tag === 'input' && \n      (elementInfo.type === 'checkbox' || elementInfo.type === 'radio')) {\n    \n    // Check if parent is a label by looking at the parent tag name\n    const isParentLabel = parent.tagName.toLowerCase() === 'label';\n    \n    // If parent is a label, don't keep the input (we'll keep the label instead)\n    if (isParentLabel) {\n      return false;\n    }\n  }\n  \n  // Keep all other form controls and dropdown items\n  if (isFormControl(elementInfo) || isDropdownItem(elementInfo)) {\n    result = true;\n  }\n  \n  // console.log(`shouldKeepNestedElement: ${elementInfo.tag} ${elementInfo.text} ${elementInfo.xpath} -> ${parentXPath} -> ${result}`);\n  return result;\n}\n\n// Helper function to check if element is a form control\nfunction isFormControl(elementInfo) {\n  return /^(input|select|textarea|button|label)$/i.test(elementInfo.tag);\n}\n\nconst isDropdownItem = (elementInfo) => {\n  const dropdownPatterns = [\n    /dropdown[-_]?item/i,    // matches: dropdown-item, dropdownitem, dropdown_item\n    /menu[-_]?item/i,        // matches: menu-item, menuitem, menu_item\n    /dropdown[-_]?link/i,    // matches: dropdown-link, dropdownlink, dropdown_link\n    /list[-_]?item/i,       // matches: list-item, listitem, list_item\n    /select[-_]?item/i,     // matches: select-item, selectitem, select_item  \n  ];\n\n  const rolePatterns = [\n    /menu[-_]?item/i,       // matches: menuitem, menu-item\n    /option/i,              // matches: option\n    /list[-_]?item/i,      // matches: listitem, list-item\n    /tree[-_]?item/i       // matches: treeitem, tree-item\n  ];\n\n  const hasMatchingClass = elementInfo.element.className && \n                          dropdownPatterns.some(pattern => \n                            pattern.test(elementInfo.element.className)\n                          );\n\n  const hasMatchingRole = elementInfo.element.getAttribute('role') && \n                         rolePatterns.some(pattern => \n                           pattern.test(elementInfo.element.getAttribute('role'))\n                         );\n\n  return hasMatchingClass || hasMatchingRole;\n};\n","import { uniquifyElements } from './utils';\n\nfunction getAllElementsIncludingShadow(selectors, root = document) {\n  const elements = Array.from(root.querySelectorAll(selectors));\n  root.querySelectorAll('*').forEach(el => {\n      if (el.shadowRoot) {\n          elements.push(...getAllElementsIncludingShadow(selectors, el.shadowRoot));\n      }\n  });\n  return elements;\n}\n\nexport function findDropdowns() {\n  const dropdowns = [];\n  \n  // Native select elements\n  dropdowns.push(...getAllElementsIncludingShadow('select'));\n  \n  // Elements with dropdown roles\n  dropdowns.push(...getAllElementsIncludingShadow('[role=\"combobox\"], [role=\"listbox\"], [role=\"dropdown\"]'));\n  \n  // Common dropdown class patterns\n  const dropdownPattern = /.*(dropdown|select|combobox).*/i;\n  const elements = getAllElementsIncludingShadow('*');\n  const dropdownClasses = Array.from(elements).filter(el => {\n    const hasDropdownClass = dropdownPattern.test(el.className);\n    const validTag = ['li', 'ul', 'span', 'div', 'p'].includes(el.tagName.toLowerCase());\n    const result = hasDropdownClass && validTag;\n    return result;\n  });\n  dropdowns.push(...dropdownClasses);\n  \n  // Elements with aria-haspopup attribute\n  dropdowns.push(...getAllElementsIncludingShadow('[aria-haspopup=\"true\"], [aria-haspopup=\"listbox\"]'));\n\n  dropdowns.push(...getAllElementsIncludingShadow('nav ul li'));\n\n  return dropdowns;\n}\n\nexport function findClickables() {\n  const clickables = [];\n  \n  // Collect all clickable elements first\n  const links = [...getAllElementsIncludingShadow('a[href]')];\n  const buttons = [...getAllElementsIncludingShadow('button')];\n  const inputButtons = [...getAllElementsIncludingShadow('input[type=\"button\"], input[type=\"submit\"], input[type=\"reset\"]')];\n  const roleButtons = [...getAllElementsIncludingShadow('[role=\"button\"]')];\n  const tabbable = [...getAllElementsIncludingShadow('[tabindex=\"0\"]')];\n  const clickHandlers = [...getAllElementsIncludingShadow('[onclick]')];\n  const dropdowns = findDropdowns();\n  const checkboxes = [...getAllElementsIncludingShadow('input[type=\"checkbox\"]')];\n  const radios = [...getAllElementsIncludingShadow('input[type=\"radio\"]')];\n  const toggles = findToggles();\n  const pointerElements = findElementsWithPointer();\n  // Add all elements at once\n  clickables.push(\n    ...links,\n    ...buttons,\n    ...inputButtons,\n    ...roleButtons,\n    ...tabbable,\n    ...clickHandlers,\n    ...dropdowns,\n    ...checkboxes,\n    ...radios,\n    ...toggles,\n    ...pointerElements\n  );\n\n  // Only uniquify once at the end\n  return clickables;  // Let findElements handle the uniquification\n}\n\nexport function findToggles() {\n  const toggles = [];\n  const checkboxes = getAllElementsIncludingShadow('input[type=\"checkbox\"]');\n  const togglePattern = /switch|toggle|slider/i;\n\n  checkboxes.forEach(checkbox => {\n    let isToggle = false;\n\n    // Check the checkbox itself\n    if (togglePattern.test(checkbox.className) || togglePattern.test(checkbox.getAttribute('role') || '')) {\n      isToggle = true;\n    }\n\n    // Check parent elements (up to 3 levels)\n    if (!isToggle) {\n      let element = checkbox;\n      for (let i = 0; i < 3; i++) {\n        const parent = element.parentElement;\n        if (!parent) break;\n\n        const className = parent.className || '';\n        const role = parent.getAttribute('role') || '';\n\n        if (togglePattern.test(className) || togglePattern.test(role)) {\n          isToggle = true;\n          break;\n        }\n        element = parent;\n      }\n    }\n\n    // Check next sibling\n    if (!isToggle) {\n      const nextSibling = checkbox.nextElementSibling;\n      if (nextSibling) {\n        const className = nextSibling.className || '';\n        const role = nextSibling.getAttribute('role') || '';\n        if (togglePattern.test(className) || togglePattern.test(role)) {\n          isToggle = true;\n        }\n      }\n    }\n\n    if (isToggle) {\n      toggles.push(checkbox);\n    }\n  });\n\n  return toggles;\n}\n\nexport function findNonInteractiveElements() {\n  // Get all elements in the document\n  const all = Array.from(getAllElementsIncludingShadow('*'));\n  \n  // Filter elements based on Python implementation rules\n  return all.filter(element => {\n    if (!element.firstElementChild) {\n      const tag = element.tagName.toLowerCase();\n      if (!['select', 'button', 'a'].includes(tag)) {\n        return ['p', 'span', 'div', 'input', 'textarea'].includes(tag) || /^h\\d$/.test(tag);\n      }\n    }\n    return false;\n  });\n}\n\nexport function findElementsWithPointer() {\n  const elements = [];\n  // const allElements = document.querySelectorAll('*');\n  const allElements = getAllElementsIncludingShadow('*');\n  \n  console.log('Checking elements with pointer style...');\n  \n  allElements.forEach(element => {\n    // Skip SVG elements for now\n    if (element instanceof SVGElement) {\n      return;\n    }\n    \n    const style = window.getComputedStyle(element);\n    if (style.cursor === 'pointer') {\n      elements.push(element);\n    }\n  });\n  \n  console.log(`Found ${elements.length} elements with pointer cursor`);\n  return elements;\n}\n","import { ElementTag } from './constants';\nimport { findDropdowns, findClickables, findToggles, findNonInteractiveElements } from './finders';\nimport { uniquifyElements, getElementInfo, getElementByXPathOrCssSelector } from './utils';\n\nexport const highlight = {\n  execute: async function(elementTypes) {\n    const elements = await findElements(elementTypes);\n    highlightElements(elements);\n    return elements;\n  },\n\n  unexecute: function() {\n    const overlay = document.getElementById('highlight-overlay');\n    if (overlay) {\n      overlay.remove();\n    }\n  },\n\n  getElementInfo\n};\n\n\nexport function unhighlightElements() {\n  const overlay = document.getElementById('highlight-overlay');\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\n\n\n\nexport async function findElements(elementTypes) {\n  const typesArray = Array.isArray(elementTypes) ? elementTypes : [elementTypes];\n  console.log('Starting element search for types:', typesArray);\n\n  const elements = [];\n  typesArray.forEach(elementType => {\n    if (elementType === ElementTag.FILLABLE) {\n      const inputs = [...document.querySelectorAll('input:not([type=\"radio\"]):not([type=\"checkbox\"])')];\n      console.log('Found inputs:', inputs.length, inputs);\n      elements.push(...inputs);\n      \n      const textareas = [...document.querySelectorAll('textarea')];\n      console.log('Found textareas:', textareas.length);\n      elements.push(...textareas);\n      \n      const editables = [...document.querySelectorAll('[contenteditable=\"true\"]')];\n      console.log('Found editables:', editables.length);\n      elements.push(...editables);\n    }\n    if (elementType === ElementTag.SELECTABLE) {\n      elements.push(...findDropdowns());\n    }\n    if (elementType === ElementTag.CLICKABLE) {\n      elements.push(...findClickables());\n      elements.push(...findToggles());\n      elements.push(...document.querySelectorAll('input[type=\"checkbox\"]'));\n      elements.push(...document.querySelectorAll('input[type=\"radio\"]'));\n    }\n    if (elementType === ElementTag.NON_INTERACTIVE_ELEMENT) {\n      elements.push(...findNonInteractiveElements());\n    }\n  });\n\n  // console.log('Before uniquify:', elements.length);\n  const elementsWithInfo = elements.map((element, index) => \n    getElementInfo(element, index)\n  );\n  \n  const uniqueElements = uniquifyElements(elementsWithInfo);\n  console.log(`Found ${uniqueElements.length} elements:`);\n  uniqueElements.forEach(info => {\n    console.log(`Element ${info.index}:`, info);\n  });\n  \n  return uniqueElements;\n}\n\n// elements is an array of objects with index, xpath\nexport function highlightElements(elements) {\n  // console.log('Starting highlight for elements:', elements);\n  \n  // Create overlay if it doesn't exist\n  let overlay = document.getElementById('highlight-overlay');\n  if (!overlay) {\n    overlay = document.createElement('div');\n    overlay.id = 'highlight-overlay';\n    overlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      pointer-events: none;\n      z-index: 10000;\n    `;\n    document.body.appendChild(overlay);\n  }\n  \n  \n\n  const updateHighlights = () => {\n    overlay.innerHTML = '';\n    \n    elements.forEach(elementInfo => {\n      let element = elementInfo.element; //getElementByXPathOrCssSelector(elementInfo);\n      if (!element) {\n        element = getElementByXPathOrCssSelector(elementInfo);\n        if (!element)\n          return;\n      }\n      \n      const rect = element.getBoundingClientRect();\n      // console.log('Element rect:', elementInfo.tag, rect);\n      \n      if (rect.width === 0 || rect.height === 0) {\n        console.warn('Element has zero dimensions:', elementInfo);\n        return;\n      }\n      \n      // Create border highlight (red rectangle)\n      const highlight = document.createElement('div');\n      highlight.style.cssText = `\n        position: fixed;\n        left: ${rect.x}px;\n        top: ${rect.y}px;\n        width: ${rect.width}px;\n        height: ${rect.height}px;\n        border: 1px solid rgb(255, 0, 0);\n        transition: all 0.2s ease-in-out;\n      `;\n\n      // Create index label container - now positioned to the right and slightly up\n      const labelContainer = document.createElement('div');\n      labelContainer.style.cssText = `\n        position: absolute;\n        right: -10px;     /* Offset to the right */\n        top: -10px;       /* Offset upwards */\n        padding: 4px;\n        background-color: rgba(255, 255, 0, 0.6);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      `;\n\n      const text = document.createElement('span');\n      text.style.cssText = `\n        color: rgb(0, 0, 0, 0.8);\n        font-family: 'Courier New', Courier, monospace;\n        font-size: 12px;\n        font-weight: bold;\n        line-height: 1;\n      `;\n      text.textContent = elementInfo.index;\n      \n      labelContainer.appendChild(text);\n      highlight.appendChild(labelContainer);\n      overlay.appendChild(highlight);\n    });\n  };\n\n  // Initial highlight\n  updateHighlights();\n\n  // Update highlights on scroll and resize\n  const scrollHandler = () => {\n    requestAnimationFrame(updateHighlights);\n  };\n  \n  window.addEventListener('scroll', scrollHandler, true);\n  window.addEventListener('resize', updateHighlights);\n\n  // Store event handlers for cleanup\n  overlay.scrollHandler = scrollHandler;\n  overlay.updateHighlights = updateHighlights;\n}\n\nfunction unexecute() {\n  const overlay = document.getElementById('highlight-overlay');\n  if (overlay) {\n    // Remove event listeners\n    window.removeEventListener('scroll', overlay.scrollHandler, true);\n    window.removeEventListener('resize', overlay.updateHighlights);\n    overlay.remove();\n  }\n}\n\n// Make it available globally for both Extension and Playwright\nif (typeof window !== 'undefined') {\n  window.ProboLabs = {\n    ElementTag,\n    highlight,\n    unhighlightElements,\n    findElements,\n    highlightElements\n  };\n}\n\n\n"],"names":["ElementTag","CLICKABLE","FILLABLE","SELECTABLE","NON_INTERACTIVE_ELEMENT","ElementInfo","constructor","element","index","tag","type","text","html","xpath","css_selector","bounding_box","this","toString","depth","getSelector","getDepth","currentElement","nodeType","Node","ELEMENT_NODE","parentElement","getRootNode","ShadowRoot","host","cleanHTML","rawHTML","doc","DOMParser","parseFromString","Array","from","body","children","forEach","cleanElement","allowedAttributes","Set","attributes","attr","name","toLowerCase","value","isTestAttribute","test","isDataAttribute","startsWith","isBooleanAttribute","includes","has","removeAttribute","tagName","innerHTML","length","textContent","trim","remove","getElementInfo","id","parts","current","sibling","previousSibling","unshift","parentNode","join","generateXPath","path","selector","nodeName","nth","previousElementSibling","singleChild","nextElementSibling","assignedSlot","generateCssPath","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","node","nextNode","trimmedText","getTextContent","outerHTML","getBoundingClientRect","filterZeroDimensions","elementInfo","rect","hasSize","width","height","style","window","getComputedStyle","isVisible","display","visibility","uniquifyElements","elements","seen","console","log","nonZeroElements","filter","sort","a","b","element_info","add","info","filteredByParent","parent","segments","split","i","parentPath","slice","findClosestParent","keep","result","isFormControl","isDropdownItem","shouldKeepNestedElement","filteredResults","some","other","indexOf","areElementsOverlapping","element1","element2","box1","box2","x","y","hasMatchingClass","className","pattern","hasMatchingRole","getAttribute","getAllElementsIncludingShadow","selectors","root","querySelectorAll","el","shadowRoot","push","findDropdowns","dropdowns","dropdownPattern","dropdownClasses","hasDropdownClass","validTag","findClickables","clickables","links","buttons","inputButtons","roleButtons","tabbable","clickHandlers","checkboxes","radios","toggles","findToggles","pointerElements","allElements","SVGElement","cursor","findElementsWithPointer","togglePattern","checkbox","isToggle","role","nextSibling","highlight","execute","async","elementTypes","findElements","highlightElements","unexecute","overlay","getElementById","unhighlightElements","typesArray","isArray","elementType","inputs","textareas","editables","firstElementChild","uniqueElements","map","createElement","cssText","appendChild","updateHighlights","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","warn","querySelector","getElementByXPathOrCssSelector","labelContainer","scrollHandler","requestAnimationFrame","addEventListener","ProboLabs"],"mappings":"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"}