{"version":3,"file":"probolabs.esm.js","sources":["../src/constants.js","../src/utils.js","../src/finders.js","../src/highlight.js"],"sourcesContent":["export const ElementTag = {\r\n  CLICKABLE: \"CLICKABLE\", // button, link, toggle switch, checkbox, radio, dropdowns, clickable divs\r\n  FILLABLE: \"FILLABLE\", // input, textarea content_editable, date picker??\r\n  SELECTABLE: \"SELECTABLE\", // select\r\n  NON_INTERACTIVE_ELEMENT: 'NON_INTERACTIVE_ELEMENT',\r\n};\r\n\r\nexport class ElementInfo {\r\n  constructor(element, index, {tag, type, text, html, xpath, css_selector, bounding_box}) {\r\n    this.index = index.toString();\r\n    this.tag = tag;\r\n    this.type = type;\r\n    this.text = text;\r\n    this.html = html;\r\n    this.xpath = xpath;\r\n    this.css_selector = css_selector;\r\n    this.bounding_box = bounding_box;\r\n    this.element = element;\r\n    this.depth = -1;\r\n  }\r\n\r\n  getSelector() {\r\n    return this.xpath ? this.xpath : this.css_selector;\r\n  }\r\n\r\n  getDepth() {\r\n    if (this.depth >= 0) {\r\n      return this.depth;\r\n    }\r\n\r\n    // Handle shadow DOM by counting host elements as 1 level\r\n    let depth = 0;\r\n    let currentElement = this.element;\r\n    \r\n    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\r\n      depth++;\r\n      \r\n      currentElement = currentElement.parentElement;      \r\n      if (currentElement && currentElement.getRootNode() instanceof ShadowRoot) {\r\n        // Skip to shadow host, counting it as one level\r\n        currentElement = currentElement.getRootNode().host;\r\n      }\r\n    }\r\n    \r\n    this.depth = depth;\r\n    return this.depth;\r\n  }\r\n}\r\n","import { ElementInfo } from './constants';\r\n\r\n\r\n\r\nexport const getElementByXPathOrCssSelector = (element_info) => {\r\n  let element;\r\n\r\n  if (element_info.xpath) { //try xpath if exists\r\n    element = document.evaluate(\r\n      element_info.xpath, \r\n      document, \r\n      null, \r\n      XPathResult.FIRST_ORDERED_NODE_TYPE, \r\n      null\r\n    ).singleNodeValue;\r\n  \r\n    if (!element) {\r\n      console.warn('Failed to find element with xpath:', element_info.xpath);\r\n    }\r\n  }\r\n  else { //try CSS selector\r\n    element = document.querySelector(element_info.css_selector);\r\n    // console.log('found element by CSS elector: ', element);\r\n    if (!element) {\r\n      console.warn('Failed to find element with CSS selector:', element_info.css_selector);\r\n    }\r\n  }\r\n\r\n  return element;\r\n};\r\n\r\nexport function generateXPath(element) {\r\n  if (!element || element.getRootNode() instanceof ShadowRoot) return '';\r\n  \r\n  // If element has an id, use that (it's unique and shorter)\r\n  if (element.id) {\r\n    return `//*[@id=\"${element.id}\"]`;\r\n  }\r\n  \r\n  const parts = [];\r\n  let current = element;\r\n  \r\n  while (current && current.nodeType === Node.ELEMENT_NODE) {\r\n    let index = 1;\r\n    let sibling = current.previousSibling;\r\n    \r\n    while (sibling) {\r\n      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === current.tagName) {\r\n        index++;\r\n      }\r\n      sibling = sibling.previousSibling;\r\n    }\r\n    \r\n    const tagName = current.tagName.toLowerCase();\r\n    parts.unshift(`${tagName}[${index}]`);\r\n    current = current.parentNode;\r\n  }\r\n  \r\n  return '/' + parts.join('/');\r\n}\r\n\r\nexport function generateCssPath(element) {\r\n  const path = [];\r\n  while (element.nodeType === Node.ELEMENT_NODE) {    \r\n    let selector = element.nodeName.toLowerCase();\r\n    \r\n    if (element.id) {\r\n      selector = `#${element.id}`;\r\n      path.unshift(selector);\r\n      break;\r\n    } \r\n    else {\r\n      let sibling = element;\r\n      let nth = 1;\r\n      while (sibling = sibling.previousElementSibling) {\r\n        if (sibling.nodeName.toLowerCase() === selector) nth++;\r\n      }\r\n      sibling = element;\r\n      let singleChild = true;\r\n      while (sibling = sibling.nextElementSibling) {\r\n        if (sibling.nodeName.toLowerCase() === selector) {\r\n          singleChild = false;\r\n          break;\r\n        }\r\n      }\r\n      if (nth > 1 || !singleChild) selector += `:nth-of-type(${nth})`;\r\n    }\r\n    path.unshift(selector);\r\n    element = element.parentNode;\r\n    // Check if we're at a shadow root\r\n    if (element.getRootNode() instanceof ShadowRoot) {\r\n      // Get the shadow root's host element\r\n      element = element.getRootNode().host;     \r\n    }\r\n  }\r\n  return path.join(' > ');\r\n}\r\n\r\nexport function cleanHTML(rawHTML) {\r\n  const parser = new DOMParser();\r\n  const doc = parser.parseFromString(rawHTML, \"text/html\");\r\n\r\n  function cleanElement(element) {\r\n    const allowedAttributes = new Set([\r\n      \"role\",\r\n      \"type\",\r\n      \"class\",\r\n      \"href\",\r\n      \"alt\",\r\n      \"title\",\r\n      \"readonly\",\r\n      \"checked\",\r\n      \"enabled\",\r\n      \"disabled\",\r\n    ]);\r\n\r\n    [...element.attributes].forEach(attr => {\r\n      const name = attr.name.toLowerCase();\r\n      const value = attr.value;\r\n\r\n      const isTestAttribute = /^(testid|test-id|data-test-id)$/.test(name);\r\n      const isDataAttribute = name.startsWith(\"data-\") && value;\r\n      const isBooleanAttribute = [\"readonly\", \"checked\", \"enabled\", \"disabled\"].includes(name);\r\n\r\n      if (!allowedAttributes.has(name) && !isDataAttribute && !isTestAttribute && !isBooleanAttribute) {\r\n        element.removeAttribute(name);\r\n      }\r\n    });\r\n\r\n    // Handle SVG content - more aggressive replacement\r\n    if (element.tagName.toLowerCase() === \"svg\") {\r\n      // Remove all attributes except class and role\r\n      [...element.attributes].forEach(attr => {\r\n        const name = attr.name.toLowerCase();\r\n        if (name !== \"class\" && name !== \"role\") {\r\n          element.removeAttribute(name);\r\n        }\r\n      });\r\n      element.innerHTML = \"CONTENT REMOVED\";\r\n    } else {\r\n      // Recursively clean child elements\r\n      Array.from(element.children).forEach(cleanElement);\r\n    }\r\n\r\n    // Only remove empty elements that aren't semantic or icon elements\r\n    const keepEmptyElements = ['i', 'span', 'svg', 'button', 'input'];\r\n    if (!keepEmptyElements.includes(element.tagName.toLowerCase()) && \r\n        !element.children.length && \r\n        !element.textContent.trim()) {\r\n      element.remove();\r\n    }\r\n  }\r\n\r\n  // Process all elements in the document body\r\n  Array.from(doc.body.children).forEach(cleanElement);\r\n  return doc.body.innerHTML;\r\n}\r\n\r\nexport function getElementInfo(element, index) {\r\n  // Get text content with spaces between elements\r\n  function getTextContent(element) {\r\n    const walker = document.createTreeWalker(\r\n      element,\r\n      NodeFilter.SHOW_TEXT,\r\n      null,\r\n      false\r\n    );\r\n\r\n    let text = '';\r\n    let node;\r\n\r\n    while (node = walker.nextNode()) {\r\n      const trimmedText = node.textContent.trim();\r\n      if (trimmedText) {\r\n        // Add space if there's already text\r\n        if (text) {\r\n          text += ' ';\r\n        }\r\n        text += trimmedText;\r\n      }\r\n    }\r\n\r\n    return text;\r\n  }\r\n\r\n  const xpath = generateXPath(element);\r\n  const css_selector = generateCssPath(element);\r\n\r\n  // Return element info with pre-calculated values\r\n  return new ElementInfo(element, index, {\r\n    tag: element.tagName.toLowerCase(),\r\n    type: element.type || '',\r\n    text: getTextContent(element),\r\n    // html: cleanHTML(element.outerHTML),\r\n    xpath: xpath,\r\n    css_selector: css_selector,\r\n    bounding_box: element.getBoundingClientRect()\r\n  });\r\n}\r\n\r\n\r\n\r\n\r\nconst filterZeroDimensions = (elementInfo) => {\r\n  const rect = elementInfo.bounding_box;\r\n  const hasSize = rect.width > 0 && rect.height > 0;\r\n  const style = window.getComputedStyle(elementInfo.element);\r\n  const isVisible = style.display !== 'none' && style.visibility !== 'hidden';\r\n  \r\n  if (!hasSize || !isVisible) {\r\n    // if (elementInfo.element.isConnected) {\r\n    //   console.log('Filtered out invisible/zero-size element:', {\r\n    //     tag: elementInfo.tag,\r\n    //     xpath: elementInfo.xpath,\r\n    //     element: elementInfo.element,\r\n    //     hasSize,\r\n    //     isVisible,\r\n    //     dimensions: rect\r\n    //   });\r\n    // }\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nexport function uniquifyElements(elements) {\r\n  const seen = new Set();\r\n  console.log(`Starting uniquification with ${elements.length} elements`);\r\n  // First filter out elements with zero dimensions\r\n  const nonZeroElements = elements.filter(filterZeroDimensions);\r\n  // sort by CSS selector depth so parents are processed first\r\n  nonZeroElements.sort((a, b) => a.getDepth() - b.getDepth());\r\n  console.log(`After dimension filtering: ${nonZeroElements.length} elements remain (${elements.length - nonZeroElements.length} removed)`);\r\n  \r\n  nonZeroElements.forEach(element_info => seen.add(element_info.css_selector));\r\n    \r\n  nonZeroElements.forEach(info => {\r\n    if (!info.xpath) {\r\n      console.log(`Element ${info.index}:`, info);\r\n    }\r\n  });\r\n  const filteredByParent = nonZeroElements.filter(element_info => {\r\n    const parent = findClosestParent(seen, element_info);\r\n    const keep = parent == null || shouldKeepNestedElement(element_info, parent);\r\n    // if (!keep && !element_info.xpath) {\r\n    //   console.log(\"Filtered out element \", element_info,\" because it's a nested element of \", parent);\r\n    // }\r\n    return keep;\r\n  });\r\n\r\n  console.log(`After parent/child filtering: ${filteredByParent.length} elements remain (${nonZeroElements.length - filteredByParent.length} removed)`);\r\n\r\n  // Final overlap filtering\r\n  const filteredResults = filteredByParent.filter(element => {\r\n    // Look for any element that came BEFORE this one in the array\r\n    const hasEarlierOverlap = filteredByParent.some(other => {\r\n      // Only check elements that came before (lower index)\r\n      if (filteredByParent.indexOf(other) >= filteredByParent.indexOf(element)) {\r\n        return false;\r\n      }\r\n      \r\n      return areElementsOverlapping(element, other);\r\n    });\r\n\r\n    // Keep element if it has no earlier overlapping elements\r\n    return !hasEarlierOverlap;\r\n  });\r\n  \r\n  // further cleanup of of the element html to remove any element that we have already seen\r\n  \r\n\r\n  console.log(`Final elements after filtering: ${filteredResults.length} (${filteredByParent.length - filteredResults.length} removed by overlap)`);\r\n  \r\n  // for debugging purposes, add a data-probolabs_index attribute to the element\r\n  filteredResults.forEach((elementInfo, index) => {\r\n    // elementInfo.index = index.toString();\r\n    const foundElement = elementInfo.element; //getElementByXPathOrCssSelector(element);\r\n    if (foundElement) {\r\n      foundElement.dataset.probolabs_index = index.toString();\r\n    }\r\n  });\r\n\r\n  // final path cleanup the html\r\n  filteredResults.forEach(elementInfo => {\r\n    const foundElement = elementInfo.element; //getElementByXPathOrCssSelector(element);\r\n    if (foundElement) {\r\n      //  const parser = new DOMParser();\r\n      //  const doc = parser.parseFromString(foundElement.outerHTML, \"text/html\");\r\n      //  doc.querySelectorAll('[data-probolabs_index]').forEach(el => {\r\n      //    if (el.dataset.probolabs_index !== element.index) {\r\n      //      el.remove();\r\n      //    }\r\n      //  });\r\n      //  // Get the first element from the processed document\r\n      //  const container = doc.body.firstElementChild;\r\n      const clone = foundElement.cloneNode(false);  // false = don't clone children\r\n      elementInfo.element.html = clone.outerHTML;\r\n    }\r\n  });\r\n\r\n  return filteredResults;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nconst areElementsOverlapping = (element1, element2) => {\r\n  if (element1.css_selector === element2.css_selector) {\r\n    return true;\r\n  }\r\n  \r\n  const box1 = element1.bounding_box;\r\n  const box2 = element2.bounding_box;\r\n  \r\n  return box1.x === box2.x &&\r\n         box1.y === box2.y &&\r\n         box1.width === box2.width &&\r\n         box1.height === box2.height;\r\n        //  element1.text === element2.text &&\r\n        //  element2.tag === 'a';\r\n};\r\n\r\nfunction findClosestParent(seen, element_info) {  \r\n  // //Use element child/parent queries\r\n  // let parent = element_info.element.parentNode;\r\n  // if (parent.getRootNode() instanceof ShadowRoot) {\r\n  //   // Get the shadow root's host element\r\n  //   parent = parent.getRootNode().host;    \r\n  // }\r\n\r\n  // while (parent.nodeType === Node.ELEMENT_NODE) {    \r\n  //   const css_selector = generateCssPath(parent);\r\n  //   if (seen.has(css_selector)) {\r\n  //       console.log(\"element \", element_info, \" closest parent is \", parent)\r\n  //       return parent;      \r\n  //   }\r\n  //   parent = parent.parentNode;\r\n  //   if (parent.getRootNode() instanceof ShadowRoot) {\r\n  //     // Get the shadow root's host element\r\n  //     parent = parent.getRootNode().host;      \r\n  //   }\r\n  // }\r\n\r\n  // Split the xpath into segments\r\n  const segments = element_info.css_selector.split(' > ');\r\n  \r\n  // Try increasingly shorter paths until we find one in the seen set\r\n  for (let i = segments.length - 1; i > 0; i--) {\r\n    const parentPath = segments.slice(0, i).join(' > ');\r\n    if (seen.has(parentPath)) {\r\n      return parentPath;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction shouldKeepNestedElement(elementInfo, parent) {\r\n  let result = false;\r\n  \r\n  // If this is a checkbox/radio input\r\n  if (elementInfo.tag === 'input' && \r\n      (elementInfo.type === 'checkbox' || elementInfo.type === 'radio')) {\r\n    \r\n    // Check if parent is a label by looking at the parent tag name\r\n    const isParentLabel = parent.tagName.toLowerCase() === 'label';\r\n    \r\n    // If parent is a label, don't keep the input (we'll keep the label instead)\r\n    if (isParentLabel) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Keep all other form controls and dropdown items\r\n  if (isFormControl(elementInfo) || isDropdownItem(elementInfo)) {\r\n    result = true;\r\n  }\r\n  \r\n  // console.log(`shouldKeepNestedElement: ${elementInfo.tag} ${elementInfo.text} ${elementInfo.xpath} -> ${parentXPath} -> ${result}`);\r\n  return result;\r\n}\r\n\r\n// Helper function to check if element is a form control\r\nfunction isFormControl(elementInfo) {\r\n  return /^(input|select|textarea|button)$/i.test(elementInfo.tag);\r\n}\r\n\r\nconst isDropdownItem = (elementInfo) => {\r\n  const dropdownPatterns = [\r\n    /dropdown[-_]?item/i,    // matches: dropdown-item, dropdownitem, dropdown_item\r\n    /menu[-_]?item/i,        // matches: menu-item, menuitem, menu_item\r\n    /dropdown[-_]?link/i,    // matches: dropdown-link, dropdownlink, dropdown_link\r\n    /list[-_]?item/i,       // matches: list-item, listitem, list_item\r\n    /select[-_]?item/i,     // matches: select-item, selectitem, select_item  \r\n  ];\r\n\r\n  const rolePatterns = [\r\n    /menu[-_]?item/i,       // matches: menuitem, menu-item\r\n    /option/i,              // matches: option\r\n    /list[-_]?item/i,      // matches: listitem, list-item\r\n    /tree[-_]?item/i       // matches: treeitem, tree-item\r\n  ];\r\n\r\n  const hasMatchingClass = elementInfo.element.className && \r\n                          dropdownPatterns.some(pattern => \r\n                            pattern.test(elementInfo.element.className)\r\n                          );\r\n\r\n  const hasMatchingRole = elementInfo.element.getAttribute('role') && \r\n                         rolePatterns.some(pattern => \r\n                           pattern.test(elementInfo.element.getAttribute('role'))\r\n                         );\r\n\r\n  return hasMatchingClass || hasMatchingRole;\r\n};\r\n","import { uniquifyElements } from './utils';\r\n\r\nfunction getAllElementsIncludingShadow(selectors, root = document) {\r\n  const elements = Array.from(root.querySelectorAll(selectors));\r\n  root.querySelectorAll('*').forEach(el => {\r\n      if (el.shadowRoot) {\r\n          elements.push(...getAllElementsIncludingShadow(selectors, el.shadowRoot));\r\n      }\r\n  });\r\n  return elements;\r\n}\r\n\r\nexport function findDropdowns() {\r\n  const dropdowns = [];\r\n  \r\n  // Native select elements\r\n  dropdowns.push(...getAllElementsIncludingShadow('select'));\r\n  \r\n  // Elements with dropdown roles\r\n  dropdowns.push(...getAllElementsIncludingShadow('[role=\"combobox\"], [role=\"listbox\"], [role=\"dropdown\"]'));\r\n  \r\n  // Common dropdown class patterns\r\n  const dropdownPattern = /.*(dropdown|select|combobox).*/i;\r\n  const elements = getAllElementsIncludingShadow('*');\r\n  const dropdownClasses = Array.from(elements).filter(el => {\r\n    const hasDropdownClass = dropdownPattern.test(el.className);\r\n    const validTag = ['li', 'ul', 'span', 'div', 'p'].includes(el.tagName.toLowerCase());\r\n    const result = hasDropdownClass && validTag;\r\n    return result;\r\n  });\r\n  dropdowns.push(...dropdownClasses);\r\n  \r\n  // Elements with aria-haspopup attribute\r\n  dropdowns.push(...getAllElementsIncludingShadow('[aria-haspopup=\"true\"], [aria-haspopup=\"listbox\"]'));\r\n\r\n  dropdowns.push(...getAllElementsIncludingShadow('nav ul li'));\r\n\r\n  return dropdowns;\r\n}\r\n\r\nexport function findClickables() {\r\n  const clickables = [];\r\n  \r\n  // Collect all clickable elements first\r\n  const links = [...getAllElementsIncludingShadow('a[href]')];\r\n  const buttons = [...getAllElementsIncludingShadow('button')];\r\n  const inputButtons = [...getAllElementsIncludingShadow('input[type=\"button\"], input[type=\"submit\"], input[type=\"reset\"]')];\r\n  const roleButtons = [...getAllElementsIncludingShadow('[role=\"button\"]')];\r\n  const tabbable = [...getAllElementsIncludingShadow('[tabindex=\"0\"]')];\r\n  const clickHandlers = [...getAllElementsIncludingShadow('[onclick]')];\r\n  const dropdowns = findDropdowns();\r\n  const checkboxes = [...getAllElementsIncludingShadow('input[type=\"checkbox\"]')];\r\n  const radios = [...getAllElementsIncludingShadow('input[type=\"radio\"]')];\r\n  const toggles = findToggles();\r\n  const pointerElements = findElementsWithPointer();\r\n  // Add all elements at once\r\n  clickables.push(\r\n    ...links,\r\n    ...buttons,\r\n    ...inputButtons,\r\n    ...roleButtons,\r\n    ...tabbable,\r\n    ...clickHandlers,\r\n    ...dropdowns,\r\n    ...checkboxes,\r\n    ...radios,\r\n    ...toggles,\r\n    ...pointerElements\r\n  );\r\n\r\n  // Only uniquify once at the end\r\n  return clickables;  // Let findElements handle the uniquification\r\n}\r\n\r\nexport function findToggles() {\r\n  const toggles = [];\r\n  const checkboxes = getAllElementsIncludingShadow('input[type=\"checkbox\"]');\r\n  const togglePattern = /switch|toggle|slider/i;\r\n\r\n  checkboxes.forEach(checkbox => {\r\n    let isToggle = false;\r\n\r\n    // Check the checkbox itself\r\n    if (togglePattern.test(checkbox.className) || togglePattern.test(checkbox.getAttribute('role') || '')) {\r\n      isToggle = true;\r\n    }\r\n\r\n    // Check parent elements (up to 3 levels)\r\n    if (!isToggle) {\r\n      let element = checkbox;\r\n      for (let i = 0; i < 3; i++) {\r\n        const parent = element.parentElement;\r\n        if (!parent) break;\r\n\r\n        const className = parent.className || '';\r\n        const role = parent.getAttribute('role') || '';\r\n\r\n        if (togglePattern.test(className) || togglePattern.test(role)) {\r\n          isToggle = true;\r\n          break;\r\n        }\r\n        element = parent;\r\n      }\r\n    }\r\n\r\n    // Check next sibling\r\n    if (!isToggle) {\r\n      const nextSibling = checkbox.nextElementSibling;\r\n      if (nextSibling) {\r\n        const className = nextSibling.className || '';\r\n        const role = nextSibling.getAttribute('role') || '';\r\n        if (togglePattern.test(className) || togglePattern.test(role)) {\r\n          isToggle = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (isToggle) {\r\n      toggles.push(checkbox);\r\n    }\r\n  });\r\n\r\n  return toggles;\r\n}\r\n\r\nexport function findNonInteractiveElements() {\r\n  // Get all elements in the document\r\n  const all = Array.from(getAllElementsIncludingShadow('*'));\r\n  \r\n  // Filter elements based on Python implementation rules\r\n  return all.filter(element => {\r\n    if (!element.firstElementChild) {\r\n      const tag = element.tagName.toLowerCase();\r\n      if (!['select', 'button', 'a'].includes(tag)) {\r\n        return ['p', 'span', 'div', 'input', 'textarea'].includes(tag) || /^h\\d$/.test(tag);\r\n      }\r\n    }\r\n    return false;\r\n  });\r\n}\r\n\r\nexport function findElementsWithPointer() {\r\n  const elements = [];\r\n  // const allElements = document.querySelectorAll('*');\r\n  const allElements = getAllElementsIncludingShadow('*');\r\n  \r\n  console.log('Checking elements with pointer style...');\r\n  \r\n  allElements.forEach(element => {\r\n    // Skip SVG elements for now\r\n    if (element instanceof SVGElement) {\r\n      return;\r\n    }\r\n    \r\n    const style = window.getComputedStyle(element);\r\n    if (style.cursor === 'pointer') {\r\n      elements.push(element);\r\n    }\r\n  });\r\n  \r\n  console.log(`Found ${elements.length} elements with pointer cursor`);\r\n  return elements;\r\n}\r\n","import { ElementTag } from './constants';\r\nimport { findDropdowns, findClickables, findToggles, findNonInteractiveElements } from './finders';\r\nimport { uniquifyElements, getElementInfo, getElementByXPathOrCssSelector } from './utils';\r\n\r\nexport const highlight = {\r\n  execute: async function(elementTypes) {\r\n    const elements = await findElements(elementTypes);\r\n    highlightElements(elements);\r\n    return elements;\r\n  },\r\n\r\n  unexecute: function() {\r\n    const overlay = document.getElementById('highlight-overlay');\r\n    if (overlay) {\r\n      overlay.remove();\r\n    }\r\n  },\r\n\r\n  getElementInfo\r\n};\r\n\r\n\r\nexport function unhighlightElements() {\r\n  const overlay = document.getElementById('highlight-overlay');\r\n  if (overlay) {\r\n    overlay.remove();\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\nexport async function findElements(elementTypes) {\r\n  const typesArray = Array.isArray(elementTypes) ? elementTypes : [elementTypes];\r\n  console.log('ðŸ” Starting element search for types:', typesArray);\r\n\r\n  const elements = [];\r\n  typesArray.forEach(elementType => {\r\n    if (elementType === ElementTag.FILLABLE) {\r\n      const inputs = [...document.querySelectorAll('input:not([type=\"radio\"]):not([type=\"checkbox\"])')];\r\n      console.log('Found inputs:', inputs.length, inputs);\r\n      elements.push(...inputs);\r\n      \r\n      const textareas = [...document.querySelectorAll('textarea')];\r\n      console.log('Found textareas:', textareas.length);\r\n      elements.push(...textareas);\r\n      \r\n      const editables = [...document.querySelectorAll('[contenteditable=\"true\"]')];\r\n      console.log('Found editables:', editables.length);\r\n      elements.push(...editables);\r\n    }\r\n    if (elementType === ElementTag.SELECTABLE) {\r\n      elements.push(...findDropdowns());\r\n    }\r\n    if (elementType === ElementTag.CLICKABLE) {\r\n      elements.push(...findClickables());\r\n      elements.push(...findToggles());\r\n      elements.push(...document.querySelectorAll('input[type=\"checkbox\"]'));\r\n      elements.push(...document.querySelectorAll('input[type=\"radio\"]'));\r\n    }\r\n    if (elementType === ElementTag.NON_INTERACTIVE_ELEMENT) {\r\n      elements.push(...findNonInteractiveElements());\r\n    }\r\n  });\r\n\r\n  // console.log('Before uniquify:', elements.length);\r\n  const elementsWithInfo = elements.map((element, index) => \r\n    getElementInfo(element, index)\r\n  );\r\n  \r\n  const uniqueElements = uniquifyElements(elementsWithInfo);\r\n  console.log(`Found ${uniqueElements.length} elements:`);\r\n  uniqueElements.forEach(info => {\r\n    console.log(`Element ${info.index}:`, info);\r\n  });\r\n  \r\n  return uniqueElements;\r\n}\r\n\r\n// elements is an array of objects with index, xpath\r\nexport function highlightElements(elements) {\r\n  // console.log('Starting highlight for elements:', elements);\r\n  \r\n  // Create overlay if it doesn't exist\r\n  let overlay = document.getElementById('highlight-overlay');\r\n  if (!overlay) {\r\n    overlay = document.createElement('div');\r\n    overlay.id = 'highlight-overlay';\r\n    overlay.style.cssText = `\r\n      position: fixed;\r\n      top: 0;\r\n      left: 0;\r\n      width: 100%;\r\n      height: 100%;\r\n      pointer-events: none;\r\n      z-index: 10000;\r\n    `;\r\n    document.body.appendChild(overlay);\r\n  }\r\n  \r\n  \r\n\r\n  const updateHighlights = () => {\r\n    overlay.innerHTML = '';\r\n    \r\n    elements.forEach(elementInfo => {\r\n      const element = elementInfo.element; //getElementByXPathOrCssSelector(elementInfo);\r\n      if (!element) return;\r\n\r\n      const rect = element.getBoundingClientRect();\r\n      // console.log('Element rect:', elementInfo.tag, rect);\r\n      \r\n      if (rect.width === 0 || rect.height === 0) {\r\n        console.warn('Element has zero dimensions:', elementInfo);\r\n        return;\r\n      }\r\n      \r\n      // Create border highlight (red rectangle)\r\n      const highlight = document.createElement('div');\r\n      highlight.style.cssText = `\r\n        position: fixed;\r\n        left: ${rect.x}px;\r\n        top: ${rect.y}px;\r\n        width: ${rect.width}px;\r\n        height: ${rect.height}px;\r\n        border: 1px solid rgb(255, 0, 0);\r\n        transition: all 0.2s ease-in-out;\r\n      `;\r\n\r\n      // Create index label container - now positioned to the right and slightly up\r\n      const labelContainer = document.createElement('div');\r\n      labelContainer.style.cssText = `\r\n        position: absolute;\r\n        right: -10px;     /* Offset to the right */\r\n        top: -10px;       /* Offset upwards */\r\n        padding: 4px;\r\n        background-color: rgba(255, 255, 0, 0.6);\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n      `;\r\n\r\n      const text = document.createElement('span');\r\n      text.style.cssText = `\r\n        color: rgb(0, 0, 0, 0.8);\r\n        font-family: 'Courier New', Courier, monospace;\r\n        font-size: 12px;\r\n        font-weight: bold;\r\n        line-height: 1;\r\n      `;\r\n      text.textContent = elementInfo.index;\r\n      \r\n      labelContainer.appendChild(text);\r\n      highlight.appendChild(labelContainer);\r\n      overlay.appendChild(highlight);\r\n    });\r\n  };\r\n\r\n  // Initial highlight\r\n  updateHighlights();\r\n\r\n  // Update highlights on scroll and resize\r\n  const scrollHandler = () => {\r\n    requestAnimationFrame(updateHighlights);\r\n  };\r\n  \r\n  window.addEventListener('scroll', scrollHandler, true);\r\n  window.addEventListener('resize', updateHighlights);\r\n\r\n  // Store event handlers for cleanup\r\n  overlay.scrollHandler = scrollHandler;\r\n  overlay.updateHighlights = updateHighlights;\r\n}\r\n\r\nfunction unexecute() {\r\n  const overlay = document.getElementById('highlight-overlay');\r\n  if (overlay) {\r\n    // Remove event listeners\r\n    window.removeEventListener('scroll', overlay.scrollHandler, true);\r\n    window.removeEventListener('resize', overlay.updateHighlights);\r\n    overlay.remove();\r\n  }\r\n}\r\n\r\n// Make it available globally for both Extension and Playwright\r\nif (typeof window !== 'undefined') {\r\n  window.ProboLabs = {\r\n    ElementTag,\r\n    highlight,\r\n    unhighlightElements,\r\n    findElements,\r\n    highlightElements\r\n  };\r\n}\r\n\r\n\r\n"],"names":["ElementTag","CLICKABLE","FILLABLE","SELECTABLE","NON_INTERACTIVE_ELEMENT","ElementInfo","constructor","element","index","tag","type","text","html","xpath","css_selector","bounding_box","this","toString","depth","getSelector","getDepth","currentElement","nodeType","Node","ELEMENT_NODE","parentElement","getRootNode","ShadowRoot","host","getElementInfo","id","parts","current","sibling","previousSibling","tagName","toLowerCase","unshift","parentNode","join","generateXPath","path","selector","nodeName","nth","previousElementSibling","singleChild","nextElementSibling","generateCssPath","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","node","nextNode","trimmedText","textContent","trim","getTextContent","getBoundingClientRect","filterZeroDimensions","elementInfo","rect","hasSize","width","height","style","window","getComputedStyle","isVisible","display","visibility","uniquifyElements","elements","seen","Set","console","log","length","nonZeroElements","filter","sort","a","b","forEach","element_info","add","info","filteredByParent","parent","segments","split","i","parentPath","slice","has","findClosestParent","keep","result","test","isFormControl","isDropdownItem","shouldKeepNestedElement","filteredResults","some","other","indexOf","areElementsOverlapping","foundElement","dataset","probolabs_index","clone","cloneNode","outerHTML","element1","element2","box1","box2","x","y","hasMatchingClass","className","pattern","hasMatchingRole","getAttribute","getAllElementsIncludingShadow","selectors","root","Array","from","querySelectorAll","el","shadowRoot","push","findDropdowns","dropdowns","dropdownPattern","dropdownClasses","hasDropdownClass","validTag","includes","findClickables","clickables","links","buttons","inputButtons","roleButtons","tabbable","clickHandlers","checkboxes","radios","toggles","findToggles","pointerElements","allElements","SVGElement","cursor","findElementsWithPointer","togglePattern","checkbox","isToggle","role","nextSibling","highlight","execute","async","elementTypes","findElements","highlightElements","unexecute","overlay","getElementById","remove","unhighlightElements","typesArray","isArray","elementType","inputs","textareas","editables","firstElementChild","uniqueElements","map","createElement","cssText","body","appendChild","updateHighlights","innerHTML","warn","labelContainer","scrollHandler","requestAnimationFrame","addEventListener","ProboLabs"],"mappings":"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"}