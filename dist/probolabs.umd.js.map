{"version":3,"file":"probolabs.umd.js","sources":["../src/constants.js","../src/utils.js","../src/finders.js","../src/highlight.js"],"sourcesContent":["export const ElementTag = {\n  CLICKABLE: \"CLICKABLE\", // button, link, toggle switch, checkbox, radio, dropdowns, clickable divs\n  FILLABLE: \"FILLABLE\", // input, textarea content_editable, date picker??\n  SELECTABLE: \"SELECTABLE\", // select\n  NON_INTERACTIVE_ELEMENT: 'NON_INTERACTIVE_ELEMENT',\n};\n","export function generateXPath(element) {\n  if (!element) return '';\n  \n  // If element has an id, use that (it's unique and shorter)\n  if (element.id) {\n    return `//*[@id=\"${element.id}\"]`;\n  }\n  \n  const parts = [];\n  let current = element;\n  \n  while (current && current.nodeType === Node.ELEMENT_NODE) {\n    let index = 1;\n    let sibling = current.previousSibling;\n    \n    while (sibling) {\n      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === current.tagName) {\n        index++;\n      }\n      sibling = sibling.previousSibling;\n    }\n    \n    const tagName = current.tagName.toLowerCase();\n    parts.unshift(`${tagName}[${index}]`);\n    current = current.parentNode;\n  }\n  \n  return '/' + parts.join('/');\n}\n\nexport function getElementInfo(element, index) {\n  // Get CSS selector\n  const getCssPath = (el) => {\n    const path = [];\n    while (el.nodeType === Node.ELEMENT_NODE) {\n      let selector = el.nodeName.toLowerCase();\n      if (el.id) {\n        selector = `#${el.id}`;\n        path.unshift(selector);\n        break;\n      } else {\n        let sibling = el;\n        let nth = 1;\n        while (sibling = sibling.previousElementSibling) {\n          if (sibling.nodeName.toLowerCase() === selector) nth++;\n        }\n        if (nth > 1) selector += `:nth-of-type(${nth})`;\n      }\n      path.unshift(selector);\n      el = el.parentNode;\n    }\n    return path.join(' > ');\n  };\n\n  // Get bounding box\n  const rect = element.getBoundingClientRect();\n  const boundingBox = {\n    x: rect.x,\n    y: rect.y,\n    width: rect.width,\n    height: rect.height\n  };\n\n  // Return element info\n  return {\n    index: index.toString(),\n    tag: element.tagName.toLowerCase(),\n    type: element.type || '',\n    text: element.textContent.trim(),\n    html: element.outerHTML,\n    xpath: generateXPath(element),\n    css_selector: getCssPath(element),\n    bounding_box: boundingBox\n  };\n}\n\nexport function uniquifyElements(elements) {\n  const elementInfos = elements.map(element => ({\n    element,\n    info: getElementInfo(element, 0)\n  }));\n\n  const seen = new Set();\n  \n  // Add debug logging\n  console.log('Uniquifying elements:');\n  elementInfos.forEach(({element, info}) => {\n    console.log(`- ${info.tag} (${info.type}): xpath=${info.xpath}, text=\"${info.text}\"`);\n  });\n  \n  return elementInfos.filter(({element, info}) => {\n    // Skip if we've seen this xpath\n    if (seen.has(info.xpath)) {\n      console.log(`Skipping duplicate xpath: ${info.xpath}`);\n      return false;\n    }\n\n    // For interactive elements, don't check text content\n    const isInteractiveElement = ['input', 'select', 'textarea', 'button'].includes(info.tag);\n    if (!isInteractiveElement) {\n      // Check if this element's text is contained within a parent's text\n      let parent = element.parentElement;\n      while (parent) {\n        // Skip if parent has same text content (indicates nesting)\n        if (parent.textContent.trim() === element.textContent.trim()) {\n          console.log(`Skipping nested text: ${info.xpath} (${info.text})`);\n          return false;\n        }\n        \n        // Check if parent is already selected\n        const parentXPath = generateXPath(parent);\n        if (seen.has(parentXPath)) {\n          console.log(`Skipping child of seen parent: ${info.xpath}`);\n          return false;\n        }\n        \n        parent = parent.parentElement;\n      }\n    }\n\n    seen.add(info.xpath);\n    return true;\n  }).map(({element}) => element);\n}\n\nexport function removeDuplicateXPaths(elements) {\n  // Sort by xpath depth to process shorter paths first\n  const sortedElements = [...elements].sort((a, b) => \n    a.xpath.split('/').length - b.xpath.split('/').length\n  );\n  \n  const seen = new Set();\n  return sortedElements.filter(({xpath}) => {\n    // Check if this xpath starts with any seen xpath\n    if (!Array.from(seen).some(seenXPath => xpath.startsWith(seenXPath))) {\n      seen.add(xpath);\n      return true;\n    }\n    return false;\n  });\n}","import { uniquifyElements } from './utils';\nexport function findDropdowns() {\n  const dropdowns = [];\n  \n  // Native select elements\n  dropdowns.push(...document.querySelectorAll('select'));\n  \n  // Elements with dropdown roles\n  dropdowns.push(...document.querySelectorAll('[role=\"combobox\"], [role=\"listbox\"], [role=\"dropdown\"]'));\n  \n  // Common dropdown class patterns\n  const dropdownPattern = /.*(dropdown|select|combobox).*/i;\n  const elements = document.querySelectorAll('*');\n  const dropdownClasses = Array.from(elements).filter(el => {\n    const hasDropdownClass = dropdownPattern.test(el.className);\n    const validTag = ['li', 'ul', 'span', 'div', 'p'].includes(el.tagName.toLowerCase());\n    const result = hasDropdownClass && validTag;\n    return result;\n  });\n  dropdowns.push(...dropdownClasses);\n  \n  // Elements with aria-haspopup attribute\n  dropdowns.push(...document.querySelectorAll('[aria-haspopup=\"true\"], [aria-haspopup=\"listbox\"]'));\n\n  dropdowns.push(...document.querySelectorAll('nav ul li'));\n\n  return dropdowns;\n}\n\nexport function findClickables() {\n  const clickables = [];\n  \n  // Collect all clickable elements first\n  const links = [...document.querySelectorAll('a[href]')];\n  const buttons = [...document.querySelectorAll('button')];\n  const inputButtons = [...document.querySelectorAll('input[type=\"button\"], input[type=\"submit\"], input[type=\"reset\"]')];\n  const roleButtons = [...document.querySelectorAll('[role=\"button\"]')];\n  const tabbable = [...document.querySelectorAll('[tabindex=\"0\"]')];\n  const clickHandlers = [...document.querySelectorAll('[onclick]')];\n  const dropdowns = findDropdowns();\n  const checkboxes = [...document.querySelectorAll('input[type=\"checkbox\"]')];\n  const radios = [...document.querySelectorAll('input[type=\"radio\"]')];\n  const toggles = findToggles();\n  \n  // Add all elements at once\n  clickables.push(\n    ...links,\n    ...buttons,\n    ...inputButtons,\n    ...roleButtons,\n    ...tabbable,\n    ...clickHandlers,\n    ...dropdowns,\n    ...checkboxes,\n    ...radios,\n    ...toggles\n  );\n\n  // Only uniquify once at the end\n  return clickables;  // Let findElements handle the uniquification\n}\n\nexport function findToggles() {\n  const toggles = [];\n  const checkboxes = document.querySelectorAll('input[type=\"checkbox\"]');\n  const togglePattern = /switch|toggle|slider/i;\n  \n  checkboxes.forEach(checkbox => {\n    let isToggle = false;\n    \n    // 1. Check the checkbox's own class and role\n    if (togglePattern.test(checkbox.className) || togglePattern.test(checkbox.getAttribute('role') || '')) {\n      isToggle = true;\n    }\n    \n    // 2. Check up to 3 parent levels\n    if (!isToggle) {\n      let current = checkbox;\n      for (let i = 0; i < 3; i++) {\n        const parent = current.parentElement;\n        if (!parent) break;\n        const parentClasses = parent.className || '';\n        const parentRole = parent.getAttribute('role') || '';\n        if (togglePattern.test(parentClasses) || togglePattern.test(parentRole)) {\n          isToggle = true;\n          break;\n        }\n        current = parent;\n      }\n    }\n    \n    // 3. Check next sibling\n    if (!isToggle) {\n      const sibling = checkbox.nextElementSibling;\n      if (sibling) {\n        const siblingClasses = sibling.className || '';\n        const siblingRole = sibling.getAttribute('role') || '';\n        if (togglePattern.test(siblingClasses) || togglePattern.test(siblingRole)) {\n          isToggle = true;\n        }\n      }\n    }\n    \n    if (isToggle) toggles.push(checkbox);\n  });\n  \n  return toggles;\n}\n\nexport function findNonInteractiveElements() {\n  // Get all elements in the document\n  const all = Array.from(document.querySelectorAll('*'));\n  \n  // Filter elements based on Python implementation rules\n  return all.filter(element => {\n    // Check if element is a leaf node (no children)\n    if (!element.firstElementChild) {\n      const tag = element.tagName.toLowerCase();\n      // Check if element is not interactive (matching Python exclusions)\n      if (!['select', 'button', 'a'].includes(tag)) {\n        // Check if element is a text or image element (matching Python inclusions)\n        return ['p', 'span', 'div', 'input', 'textarea'].includes(tag);\n      }\n    }\n    return false;\n  });\n}\n","import { ElementTag } from './constants';\nimport { findDropdowns, findClickables, findToggles, findNonInteractiveElements } from './finders';\nimport { uniquifyElements, getElementInfo } from './utils';\n\nexport const highlight = {\n  execute: async function(elementTypes) {\n    const elements = await findElements(elementTypes);\n    highlightElements(elements);\n    return elements;\n  },\n\n  unexecute: function() {\n    const overlay = document.getElementById('highlight-overlay');\n    if (overlay) {\n      overlay.remove();\n    }\n  },\n\n  getElementInfo\n};\n\n\nexport function unhighlightElements() {\n  const overlay = document.getElementById('highlight-overlay');\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\n\n\n\nexport async function findElements(elementTypes) {\n  const typesArray = Array.isArray(elementTypes) ? elementTypes : [elementTypes];\n  console.log('üîç Starting element search for types:', typesArray);\n\n  const elements = [];\n  typesArray.forEach(elementType => {\n    if (elementType === ElementTag.FILLABLE) {\n      const inputs = [...document.querySelectorAll('input:not([type=\"radio\"]):not([type=\"checkbox\"])')];\n      console.log('Found inputs:', inputs.length, inputs);\n      elements.push(...inputs);\n      \n      const textareas = [...document.querySelectorAll('textarea')];\n      console.log('Found textareas:', textareas.length);\n      elements.push(...textareas);\n      \n      const editables = [...document.querySelectorAll('[contenteditable=\"true\"]')];\n      console.log('Found editables:', editables.length);\n      elements.push(...editables);\n    }\n    if (elementType === ElementTag.SELECTABLE) {\n      elements.push(...findDropdowns());\n    }\n    if (elementType === ElementTag.CLICKABLE) {\n      elements.push(...findClickables());\n      elements.push(...findToggles());\n      elements.push(...document.querySelectorAll('input[type=\"checkbox\"]'));\n      elements.push(...document.querySelectorAll('input[type=\"radio\"]'));\n    }\n    if (elementType === ElementTag.NON_INTERACTIVE_ELEMENT) {\n      elements.push(...findNonInteractiveElements());\n    }\n  });\n\n  console.log('Before uniquify:', elements.length);\n  //const uniqueElements = uniquifyElements(elements);\n  const uniqueElements = elements;\n  console.log('After uniquify:', uniqueElements.length);\n  \n  const elementsWithInfo = uniqueElements.map((element, index) => \n    getElementInfo(element, index)\n  );\n  \n  console.log(`Found ${elementsWithInfo.length} elements:`);\n  elementsWithInfo.forEach(info => {\n    console.log(`Element ${info.index}:`, info);\n  });\n  // TBD - filter out elements that are not visible or not enabled\n  return elementsWithInfo;\n}\n\n// elements is an array of objects with index, xpath\nexport function highlightElements(elements) {\n  console.log('Starting highlight for elements:', elements);\n  \n  // Create overlay if it doesn't exist\n  let overlay = document.getElementById('highlight-overlay');\n  if (!overlay) {\n    overlay = document.createElement('div');\n    overlay.id = 'highlight-overlay';\n    overlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      pointer-events: none;\n      z-index: 10000;\n    `;\n    document.body.appendChild(overlay);\n  }\n  \n  const getElementByXPath = (xpath) => {\n    const element = document.evaluate(\n      xpath, \n      document, \n      null, \n      XPathResult.FIRST_ORDERED_NODE_TYPE, \n      null\n    ).singleNodeValue;\n    \n    if (!element) {\n      console.warn('Failed to find element with xpath:', xpath);\n    }\n    return element;\n  };\n\n  const updateHighlights = () => {\n    overlay.innerHTML = '';\n    \n    elements.forEach(elementInfo => {\n      const element = getElementByXPath(elementInfo.xpath);\n      if (!element) return;\n\n      const rect = element.getBoundingClientRect();\n      console.log('Element rect:', elementInfo.tag, rect);\n      \n      if (rect.width === 0 || rect.height === 0) {\n        console.warn('Element has zero dimensions:', elementInfo);\n        return;\n      }\n      \n      // Create border highlight (red rectangle)\n      const highlight = document.createElement('div');\n      highlight.style.cssText = `\n        position: fixed;\n        left: ${rect.x}px;\n        top: ${rect.y}px;\n        width: ${rect.width}px;\n        height: ${rect.height}px;\n        border: 1px solid rgb(255, 0, 0);\n        transition: all 0.2s ease-in-out;\n      `;\n\n      // Create index label container - now positioned to the right and slightly up\n      const labelContainer = document.createElement('div');\n      labelContainer.style.cssText = `\n        position: absolute;\n        right: -4px;     /* Offset to the right */\n        top: -4px;       /* Offset upwards */\n        padding: 4px;\n        background-color: rgb(255, 255, 0);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      `;\n\n      const text = document.createElement('span');\n      text.style.cssText = `\n        color: rgb(0, 0, 0);\n        font-family: Arial, sans-serif;\n        font-size: 12px;\n        line-height: 1;\n      `;\n      text.textContent = elementInfo.index;\n      \n      labelContainer.appendChild(text);\n      highlight.appendChild(labelContainer);\n      overlay.appendChild(highlight);\n    });\n  };\n\n  // Initial highlight\n  updateHighlights();\n\n  // Update highlights on scroll and resize\n  const scrollHandler = () => {\n    requestAnimationFrame(updateHighlights);\n  };\n  \n  window.addEventListener('scroll', scrollHandler, true);\n  window.addEventListener('resize', updateHighlights);\n\n  // Store event handlers for cleanup\n  overlay.scrollHandler = scrollHandler;\n  overlay.updateHighlights = updateHighlights;\n}\n\nfunction unexecute() {\n  const overlay = document.getElementById('highlight-overlay');\n  if (overlay) {\n    // Remove event listeners\n    window.removeEventListener('scroll', overlay.scrollHandler, true);\n    window.removeEventListener('resize', overlay.updateHighlights);\n    overlay.remove();\n  }\n}\n\n// Make it available globally for both Extension and Playwright\nif (typeof window !== 'undefined') {\n  window.ProboLabs = {\n    ElementTag,\n    highlight,\n    unhighlightElements,\n    findElements,\n    highlightElements\n  };\n}\n\n\n"],"names":["ElementTag","CLICKABLE","FILLABLE","SELECTABLE","NON_INTERACTIVE_ELEMENT","generateXPath","element","id","parts","current","nodeType","Node","ELEMENT_NODE","index","sibling","previousSibling","tagName","toLowerCase","unshift","parentNode","join","getElementInfo","rect","getBoundingClientRect","boundingBox","x","y","width","height","toString","tag","type","text","textContent","trim","html","outerHTML","xpath","css_selector","el","path","selector","nodeName","nth","previousElementSibling","getCssPath","bounding_box","findDropdowns","dropdowns","push","document","querySelectorAll","dropdownPattern","elements","dropdownClasses","Array","from","filter","hasDropdownClass","test","className","validTag","includes","findToggles","toggles","checkboxes","togglePattern","forEach","checkbox","isToggle","getAttribute","i","parent","parentElement","parentClasses","parentRole","nextElementSibling","siblingClasses","siblingRole","highlight","execute","async","elementTypes","findElements","highlightElements","unexecute","overlay","getElementById","remove","unhighlightElements","typesArray","isArray","console","log","elementType","inputs","length","textareas","editables","clickables","links","buttons","inputButtons","roleButtons","tabbable","clickHandlers","radios","findClickables","firstElementChild","uniqueElements","elementsWithInfo","map","info","createElement","style","cssText","body","appendChild","updateHighlights","innerHTML","elementInfo","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","warn","getElementByXPath","labelContainer","scrollHandler","requestAnimationFrame","window","addEventListener","ProboLabs"],"mappings":"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"}